# Jade - 範本引擎

 Jade 是一個高效能的範本引擎，它深受[Haml](http://haml-lang.com)影響，它是用javascript實現的,並且可以供[node](http://nodejs.org)使用.

 翻譯:[草依山](http://jser.me) &nbsp; [翻譯反饋](http://weibo.com/1826461472/z9jriDdmB#pl_profile_nav) &nbsp;[Fork me](https://github.com/jserme/jade/)

## 特性

  - 用戶端支援
  - 程式碼高讀取
  - 靈活的縮排
  - 塊展開
  - 混合
  - 靜態包括
  - 屬性改寫
  - 安全，預設程式碼是逸出的
  - 執行時和編譯時上下文錯誤報告 
  - 指令行下編譯jade範本
  - html 5 模式 (使用 _!!! 5_ 文件型態)
  - 在記憶體中快取(可選)
  - 合並動態和靜態標簽類別
  - 可以透過 _filters_ 修改樹
  - 範本繼承
  - 原生支援 [Express JS](http://expressjs.com) 
  - 透過 `each` 列舉物件、陣列甚至是不能列舉的物件
  - 塊注解
  - 沒有前綴的標簽
  - AST filters
  - 過濾器
    - :sass 必須已經安裝[sass.js](http://github.com/visionmedia/sass.js) 
    - :less 必須已經安裝[less.js](http://github.com/cloudhead/less.js) 
    - :markdown 必須已經安裝[markdown-js](http://github.com/evilstreak/markdown-js) 或是[node-discount](http://github.com/visionmedia/node-discount) 
    - :cdata
    - :coffeescript 必須已經安裝[coffee-script](http://jashkenas.github.com/coffee-script/) 
  - [Vim Syntax](https://github.com/digitaltoad/vim-jade)
  - [TextMate Bundle](http://github.com/miksago/jade-tmbundle)
  - [Screencasts](http://tjholowaychuk.com/post/1004255394/jade-screencast-template-engine-for-nodejs)
  - [html2jade](https://github.com/donpark/html2jade) 轉換器

## 其它實現

  - [php](http://github.com/everzet/jade.php)
  - [scala](http://scalate.fusesource.org/versions/snapshot/documentation/scaml-reference.html)
  - [ruby](http://github.com/stonean/slim)

## 安裝

透過 npm:

    npm install jade

## 瀏覽器支援

 把jade編譯為一個可供瀏覽器使用的單檔案，只需要簡單的執行:
 
    $ make jade.js

 若果你已經安裝了uglifyjs (`npm install uglify-js`)，你可以執行下面的指令它會產生所有的檔案。其實每一個正式版本裡都幫你做了這事。 
 
    $ make jade.min.js

 預設情況下，為了方便除錯Jade會把範本群組織成帶有形如 `__.lineno = 3` 的行號的形式。 
 在瀏覽器裡使用的時候，你可以透過傳遞一個選項`{ compileDebug: false }`來去掉這個。
 下面的範本
  
    p Hello #{name}

  會被翻譯成下面的函數：

```js
function anonymous(locals, attrs, escape, rethrow) {
  var buf = [];
  with (locals || {}) {
    var interp;
    buf.push('\n<p>Hello ' + escape((interp = name) == null ? '' : interp) + '\n</p>');
  }
  return buf.join("");
}
```

  透過使用Jade的 `./runtime.js`你可以在瀏覽器使用這些預先編譯的範本而不需要使用Jade, 你只需要使用runtime.js裡的工具函數, 它們會放在`jade.attrs`, `jade.escape` 這些裡。 把選項 `{ client: true }` 傳遞給 `jade.compile()`, Jade 會把這些幫助函數的參考放在`jade.attrs`, `jade.escape`.

```js
function anonymous(locals, attrs, escape, rethrow) {
  var attrs = jade.attrs, escape = jade.escape, rethrow = jade.rethrow;
  var buf = [];
  with (locals || {}) {
    var interp;
    buf.push('\n<p>Hello ' + escape((interp = name) == null ? '' : interp) + '\n</p>');
  }
  return buf.join("");
}
```

## 公開API

```javascript
    var jade = require('jade');

    // Compile a function
    var fn = jade.compile('string of jade', options);
    fn(locals);
```

### 選項

 - `self`      使用`self` 命名空間來持有本機變數. _預設為false_
 - `locals`    本機變數物件
 - `filename`  例外發生時使用，includes時必需
 - `debug`     輸出token和翻譯後的函數體
 - `compiler`  置換掉jade預設的編譯器
 - `compileDebug`  `false`的時候除錯的結構不會被輸出

## 語法 

### 行結束標志

**CRLF** 和 **CR** 會在編譯之前被轉為 **LF** 

### 標簽

標簽就是一個簡單的單字:

    html

它會被轉為 `<html></html>`

標簽也是可以有id的:

    div#container

它會被轉為 `<div id="container"></div>`

怎麼加類別呢？

    div.user-details

轉為 `<div class="user-details"></div>`

多個類別? 和id? 也是可以搞定的:

    div#foo.bar.baz

轉為 `<div id="foo" class="bar baz"></div>`

不停的div div div 很討厭啊 , 可以這樣:

    #foo
    .bar

這個算是我們的語法糖，它已經被很好的支援了，上面的會輸出：

    `<div id="foo"></div><div class="bar"></div>`

### 標籤文本 

只需要簡單的把內容放在標簽之後：

    p wahoo!

它會被著色為 `<p>wahoo!</p>`.

很帥吧，但是大段的文字怎麼辦呢：

    p
      | foo bar baz
      | rawr rawr
      | super cool
      | go jade go

著色為 `<p>foo bar baz rawr.....</p>`

怎麼和資料結合起來？ 所有型態的文字展示都可以和資料結合起來，若果我們把`{ name: 'tj', email: 'tj@vision-media.ca' }` 傳給編譯函數，下面是範本上的寫法:

    #user #{name} &lt;#{email}&gt;

它會被著色為 `<div id="user">tj &lt;tj@vision-media.ca&gt;</div>`

當就是要輸出`#{}` 的時候怎麼辦? 逸出一下!

    p \#{something}

它會輸出`<p>#{something}</p>`

同樣可以使用非逸出的變數`!{html}`, 下面的範本將直接輸出一個script標簽

    - var html = "<script></script>"
    | !{html}

內聯標簽同樣可以使用文字塊來包括文字：

    label
      | Username:
      input(name='user[name]')

或是直接使用標籤文本:

    label Username:
      input(name='user[name]')

_只_包括文字的標簽，例如`script`, `style`, 和 `textarea` 不需要前綴`|` 字元, 例如:

      html
        head
          title Example
          script
            if (foo) {
              bar();
            } else {
              baz();
            }

這裡還有一種選取，可以使用'.' 來開始一段文字塊，例如：

      p.
        foo asdf
        asdf
         asdfasdfaf
         asdf
        asd.

會被著色為:

        <p>foo asdf
        asdf
          asdfasdfaf
          asdf
        asd
        .
        </p>

這和帶一個空格的 '.' 是不一樣的, 帶空格的會被Jade的解析器忽略，當作一個普通的文字: 

    p .
    
著色為:

    <p>.</p>


需要注意的是廣西塊需要兩次逸出。例如想要輸出下面的文字：

    </p>foo\bar</p>

使用:

    p.
      foo\\bar

### 注解

單行注解和JavaScript裡是一樣的，透過"//"來開始，並且必須單獨一行：

    // just some paragraphs
    p foo
    p bar

著色為：

    <!-- just some paragraphs -->
    <p>foo</p>
    <p>bar</p>

Jade 同樣支援不輸出的注解，加一個短橫線就行了：

    //- will not output within markup
    p foo
    p bar

著色為：

    <p>foo</p>
    <p>bar</p>

### 塊注解

 塊注解也是支援的：

      body
        //
          #content
            h1 Example

著色為：

    <body>
      <!--
      <div id="content">
        <h1>Example</h1>
      </div>
      -->
    </body>

Jade 同樣很好的支援了條件注解：

    body
      //if IE
        a(href='http://www.mozilla.com/en-US/firefox/') Get Firefox


著色為：
    <body>
      <!--[if IE]>
        <a href="http://www.mozilla.com/en-US/firefox/">Get Firefox</a>
      <![endif]-->
    </body>


### 內聯

 Jade 支援以自然的模式定義標簽嵌套:

    ul
      li.first
        a(href='#') foo
      li
        a(href='#') bar
      li.last
        a(href='#') baz

### 塊展開 

   塊展開可以幫助你在一行內建立嵌套的標簽，下面的實例和上面的是一樣的：

      ul
        li.first: a(href='#') foo
        li: a(href='#') bar
        li.last: a(href='#') baz


### 屬性

Jade 現在支援使用'(' 和 ')' 作為屬性分隔符

    a(href='/login', title='View login page') Login

當一個值是 `undefined` 或是 `null` 屬性_不_會被加上,
所以呢，它不會編譯出 'something="null"'.

    div(something=null)

Boolean 屬性也是支援的:

    input(type="checkbox", checked)

使用程式碼的Boolean 屬性只有當屬性為`true`時才會輸出：

    input(type="checkbox", checked=someValue)
    
多行同樣也是可用的：

    input(type='checkbox',
      name='agreement',
      checked)

多行的時候可以不加逗點：

    input(type='checkbox'
      name='agreement'
      checked)

加班空格，格式好看一點？同樣支援

    input(
      type='checkbox'
      name='agreement'
      checked)

冒號也是支援的:

    rss(xmlns:atom="atom")

假如我有一個`user` 物件 `{ id: 12, name: 'tobi' }`
我們希望建立一個指向"/user/12"的連結 `href`, 我們可以使用普通的javascript字串連線，如下:

    a(href='/user/' + user.id)= user.name

或是我們使用jade的修改模式,這個我想很多使用Ruby或是 CoffeeScript的人會看起來像普通的js..:

   a(href='/user/#{user.id}')= user.name

`class`屬性是一個特殊的屬性，你可以直接傳遞一個陣列，例如`bodyClasses = ['user', 'authenticated']` :

    body(class=bodyClasses)

### HTML

 內聯的html是可以的，我們可以使用管線定義一段文字 :

```
html
  body
    | <h1>Title</h1>
    | <p>foo bar baz</p>
```

 或是我們可以使用`.` 來告訴Jade我們需要一段文字：

```
html
  body.
    <h1>Title</h1>
    <p>foo bar baz</p>
```

 上面的兩個實例都會著色成相同的結果：

```
<html><body><h1>Title</h1>
<p>foo bar baz</p>
</body></html>
```

 這條規則適應於在jade裡的任何文字：

```
html
  body
    h1 User <em>#{name}</em>
```

### Doctypes

加入文件型態只需要簡單的使用 `!!!`, 或是 `doctype` 跟上下面的可選項:

    !!!

會著色出 _transitional_ 文件型態, 或是:

    !!! 5

or

    !!! html

or

    doctype html

doctypes 是大小寫不敏感的, 所以下面兩個是一樣的:

    doctype Basic
    doctype basic

當然也是可以直接傳遞一段文件型態的文字：

    doctype html PUBLIC "-//W3C//DTD XHTML Basic 1.1//EN

著色後:

    <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML Basic 1.1//EN>

會輸出 _html 5_ 文件型態. 下面的預設的文件型態，可以很簡單的延伸：

```javascript
    var doctypes = exports.doctypes = {
	    '5': '<!DOCTYPE html>',
	    'xml': '<?xml version="1.0" encoding="utf-8" ?>',
	    'default': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">',
	    'transitional': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">',
	    'strict': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">',
	    'frameset': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">',
	    '1.1': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">',
	    'basic': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML Basic 1.1//EN" "http://www.w3.org/TR/xhtml-basic/xhtml-basic11.dtd">',
	    'mobile': '<!DOCTYPE html PUBLIC "-//WAPFORUM//DTD XHTML Mobile 1.2//EN" "http://www.openmobilealliance.org/tech/DTD/xhtml-mobile12.dtd">'
	};
```

透過下面的程式碼可以很簡單的改變預設的文件型態：

```javascript
    jade.doctypes.default = 'whatever you want';
```

## 過濾器

過濾器前綴 `:`, 例如 `:markdown` 會把下面塊裡的文字交給專門的函數進行處理。檢視頂部 _特性_ 裡有哪些可用的過濾器。

    body
      :markdown
        Woah! jade _and_ markdown, very **cool**
        we can even link to [stuff](http://google.com)

著色為:

       <body><p>Woah! jade <em>and</em> markdown, very <strong>cool</strong> we can even link to <a href="http://google.com">stuff</a></p></body>

## 程式碼

Jade目前支援三種型態的可執行程式碼。第一種是前綴`-`， 這是不會被輸出的：

    - var foo = 'bar';

這可以用在條件敘述或是循環中：

    - for (var key in obj)
      p= obj[key]

由於Jade的快取技術，下面的程式碼也是可以的：

    - if (foo)
      ul
        li yay
        li foo
        li worked
    - else
      p oh no! didnt work

哈哈，甚至是很長的循環也是可以的：

    - if (items.length)
      ul
        - items.forEach(function(item){
          li= item
        - })

所以你想要的！

下一步我們要_逸出_輸出的程式碼，例如我們傳回一個值，只要前綴一個`=`：   

    - var foo = 'bar'
    = foo
    h1= foo

它會著色為`bar<h1>bar</h1>`. 為了安全起見，使用`=`輸出的程式碼預設是逸出的,若果想直接輸出不逸出的值可以使用`!=`：

    p!= aVarContainingMoreHTML

Jade 同樣是設計師友善的，它可以使javascript更直接更富表現力。例如下面的給予值敘述是相等的，同時表達式還是通常的javascript：
 
     - var foo = 'foo ' + 'bar'
     foo = 'foo ' + 'bar'

Jade會把 `if`, `else if`, `else`, `until`, `while`, `unless`同別的優先對待, 但是你得記住它們還是普通的javascript：

     if foo == 'bar'
       ul
         li yay
         li foo
         li worked
     else
       p oh no! didnt work  

## 循環

盡管已經支援JavaScript原生程式碼，Jade還是支援了一些特殊的標簽，它們可以讓範本更加易於瞭解，其中之一就是`each`, 這種形式：

    each VAL[, KEY] in OBJ

一個檢查陣列的實例 ：

    - var items = ["one", "two", "three"]
    each item in items
      li= item

著色為:

    <li>one</li>
    <li>two</li>
    <li>three</li>

檢查一個陣列同時帶上索引：

    items = ["one", "two", "three"]
    each item, i in items
      li #{item}: #{i}

著色為:

    <li>one: 0</li>
    <li>two: 1</li>
    <li>three: 2</li>

檢查一個陣列的鍵值：

    obj = { foo: 'bar' }
    each val, key in obj
      li #{key}: #{val}

將會著色為：`<li>foo: bar</li>`

Jade在內定會把這些敘述轉換成原生的JavaScript敘述，就像使用 `users.forEach(function(user){`,
詞法作用域和嵌套會像在普通的JavaScript中一樣：

    each user in users
      each role in user.roles
        li= role

若果你喜歡，也可以使用`for` ：
 
    for user in users
      for role in user.roles
        li= role

## 條件敘述

Jade 條件敘述和使用了(`-`) 前綴的JavaScript敘述是一致的,然後它容許你不使用小括號，這樣會看上去對設計師更友善一點，
同時要在心裡記住這個表達式著色出的是_一般_Javascript：

    for user in users
      if user.role == 'admin'
        p #{user.name} is an admin
      else
        p= user.name

和下面的使用了一般JavaScript的程式碼是相等的：

     for user in users
       - if (user.role == 'admin')
         p #{user.name} is an admin
       - else
         p= user.name

Jade 同時支援`unless`, 這和`if (!(expr))`是等值的：

     for user in users
       unless user.isAnonymous
         p
           | Click to view
           a(href='/users/' + user.id)= user.name 

## 範本繼承

  Jade 支援透過 `block` 和 `extends` 關鍵字來實現範本繼承。 一個區塊就是一個Jade的"block" ，它將在子範本中實現，同時是支援遞歸的。
  
  Jade 塊若果沒有內容，Jade會加入預設內容，下面的程式碼預設會輸出`block scripts`, `block content`, 和 `block foot`.

```
html
  head
    h1 My Site - #{title}
    block scripts
      script(src='/jquery.js')
  body
    block content
    block foot
      #footer
        p some footer content
```

  現在我們來繼承這個佈局，簡單建立一個新檔案，像下面那樣直接使用`extends`，指定路徑（可以選取帶.jade副檔名或是不帶）. 你可以定義一個或是更多的區塊來覆蓋父級塊內容, 注意到這裡的`foot`塊_沒有_定義，所以它還會輸出父級的"some footer content"。

```
extends extend-layout

block scripts
  script(src='/jquery.js')
  script(src='/pets.js')

block content
  h1= title
  each pet in pets
    include pet
```

  同樣可以在一個子塊裡加入塊，就像下面實現的區塊`content`裡又定義了兩個可以被實現的區塊`sidebar`和`primary`，或是子範本直接實現`content`。

```
extends regular-layout

block content
  .sidebar
    block sidebar
      p nothing
  .primary
    block primary
      p nothing
```

## 包括

 Includes 容許你靜態包括一段Jade, 或是別的存放在單一檔案中的東西例如css, html。 非常常見的實例是包括頁首和頁尾。 假設我們有一個下面目錄結構的資料夾：

     ./layout.jade
     ./includes/
       ./head.jade
       ./tail.jade

下面是 _layout.jade_ 的內容:

      html
        include includes/head  
        body
          h1 My Site
          p Welcome to my super amazing site.
          include includes/foot

這兩個包括 _includes/head_ 和 _includes/foot_ 都會讀取相對於給 _layout.jade_  參數`filename` 的路徑的檔案, 這是一個絕對路徑，不用擔心Express幫你搞定這些了。Include 會解析這些檔案，並且插入到已經產生的語法樹中，然後著色為你期待的內容：

```html
<html>
  <head>
    <title>My Site</title>
    <script src="/javascripts/jquery.js">
    </script><script src="/javascripts/app.js"></script>
  </head>
  <body>
    <h1>My Site</h1>
    <p>Welcome to my super lame site.</p>
    <div id="footer">
      <p>Copyright>(c) foobar</p>
    </div>
  </body>
</html>
```

 前面已經提到，`include` 可以包括例如html或是css這樣的內容。指定一個副檔名後，Jade不會把這個檔案當作一個Jade源程式碼，並且會把它當作一個普通文字包括進來：

```
html
  body
    include content.html
```

  Include 也可以接受塊內容，指定的區塊將會附加到包括檔案 _最後_ 的區塊裡。 舉個實例，`head.jade` 包括下面的內容：

  
  ```
head
  script(src='/jquery.js')
```

 我們可以像下面給`include head`加入內容, 這裡是加入兩個指令稿.

```
html
  include head
    script(src='/foo.js')
    script(src='/bar.js')
  body
    h1 test
```


## Mixins

 Mixins在編譯的範本裡會被Jade轉為普通的JavaScript函數。 Mixins 可以還參數，但不是必需的：

      mixin list
        ul
          li foo
          li bar
          li baz

  使用不帶參數的mixin看上去非常簡單，在一個區塊外：
  
      h2 Groceries
      mixin list

  Mixins 也可以帶一個或是多個參數，參數就是普通的javascripts表達式，例如下面的實例：

      mixin pets(pets)
        ul.pets
          - each pet in pets
            li= pet

      mixin profile(user)
        .user
          h2= user.name
          mixin pets(user.pets)

   會輸出像下面的html：

```html
<div class="user">
  <h2>tj</h2>
  <ul class="pets">
    <li>tobi</li>
    <li>loki</li>
    <li>jane</li>
    <li>manny</li>
  </ul>
</div>
```

## 產生輸出 

 假設我們有下面的Jade原始程式：

```
- var title = 'yay'
h1.title #{title}
p Just an example
```

 當 `compileDebug` 選項不是`false`, Jade 會編譯時會把函數裡加上 `__.lineno = n;`, 這個參數會在編譯出錯時傳遞給`rethrow()`, 而這個函數會在Jade起始輸出時舉出一個有用的錯誤訊息。

```js
function anonymous(locals) {
  var __ = { lineno: 1, input: "- var title = 'yay'\nh1.title #{title}\np Just an example", filename: "testing/test.js" };
  var rethrow = jade.rethrow;
  try {
    var attrs = jade.attrs, escape = jade.escape;
    var buf = [];
    with (locals || {}) {
      var interp;
      __.lineno = 1;
       var title = 'yay'
      __.lineno = 2;
      buf.push('<h1');
      buf.push(attrs({ "class": ('title') }));
      buf.push('>');
      buf.push('' + escape((interp = title) == null ? '' : interp) + '');
      buf.push('</h1>');
      __.lineno = 3;
      buf.push('<p>');
      buf.push('Just an example');
      buf.push('</p>');
    }
    return buf.join("");
  } catch (err) {
    rethrow(err, __.input, __.filename, __.lineno);
  }
}
```

當`compileDebug` 參數是`false`, 這個參數會被去掉，這樣對於輕量級的瀏覽器端範本是非常有用的。結合Jade的參數和目前原始程式庫裡的 `./runtime.js` 檔案，你可以透過toString()來編譯範本而不需要在瀏覽器端執行整個Jade庫，這樣可以提昇效能，也可以減少載入的JavaScript數量。

```js
function anonymous(locals) {
  var attrs = jade.attrs, escape = jade.escape;
  var buf = [];
  with (locals || {}) {
    var interp;
    var title = 'yay'
    buf.push('<h1');
    buf.push(attrs({ "class": ('title') }));
    buf.push('>');
    buf.push('' + escape((interp = title) == null ? '' : interp) + '');
    buf.push('</h1>');
    buf.push('<p>');
    buf.push('Just an example');
    buf.push('</p>');
  }
  return buf.join("");
}
```

##  Makefile的一個實例

  透過執行`make`， 下面的Makefile實例可以把 _pages/*.jade_ 編譯為 _pages/*.html_ 。 
 
```make
JADE = $(shell find pages/*.jade)
HTML = $(JADE:.jade=.html)

all: $(HTML)
	
%.html: %.jade
	jade < $< --path $< > $@

clean:
	rm -f $(HTML)

.PHONY: clean
```

這個可以和`watch(1)` 指令起來產生像下面的行為： 

     $ watch make

## 指令行的jade(1)

```

使用: jade [options] [dir|file ...]

選項:

  -h, --help         輸出幫助訊息
  -v, --version      輸出版本號
  -o, --obj <str>    javascript選項
  -O, --out <dir>    輸出編譯後的html到<dir>
  -p, --path <path>  在處理stdio時，查詢包括檔案時的查詢路徑

Examples:

  # 編譯整個目錄
  $ jade templates

  # 產生 {foo,bar}.html
  $ jade {foo,bar}.jade

  # 在標准IO下使用jade 
  $ jade < my.jade > my.html

  # 在標准IO下使用jade, 同時指定用於查詢包括的檔案
  $ jade < my.jade -p my.jade > my.html

  # 在標准IO下使用jade 
  $ echo "h1 Jade!" | jade

  # foo, bar 目錄著色到 /tmp
  $ jade foo bar --out /tmp 

```

## License 

(The MIT License)

Copyright (c) 2009-2010 TJ Holowaychuk &lt;tj@vision-media.ca&gt;

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
'Software'), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
